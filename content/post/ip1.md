---
title: "영상처리 기초 - 1"
date: 2018-01-23T16:42:42+09:00
draft: false
tags: ["영상처리"]
categories: ["영상처리"]
author: "Jaejin Jang"
---

# 1. 영상처리 기본
## 1) 영상처리의 개념
### (1) 영상처리의 예

* sharpening
* Image segmentation
* Noise filtering
* special effect(Sepia tone effect

## (2) 영상처리 기술

* Image Transforms
* Image Transmissions
* Image Enhancement
* Image Restoration
* Image Compression
* Image Segmentation
* Representation and Description
* Recognition and Interpretation

## 1) 영상처리의 응용 분야

* 의료 영상처리 : 신경망 활용
* 문자인식
* 영상 검색 : 영상처리 기술들의 집약체
* 컴퓨터 비전 : 인간의 눈으로 확인할 수 없는 제품 결함 판단
* 인터넷에 기반한 스트리밍 기술
* 영상 압축 기술 : MPEG
* 영상 처리 관련 SW 개발
* 생물학/군사학
* 디스플레이

# 2. 컬러 공간 분석
## 1) Image Basics
### (1) Pexels 

* rectangular
* triangular
* hexagonal

### (2) N-connected neighbors 

* 4-connected 
* 8-connected 
* ambiguous

### (3) Distance metrics

* Euclidean : De(X,Y) = ((x2-y2)^2 + (y2-y1)^2)^1/2
* City Block : Dcb(X,Y) = |x1-x2| + |y1-y2|
* Chessboard : Dcb(X,y) = max{|x1-x2|,|y1-y2|}

### (4) 명암도 영상(gray image)
### (5) RGB 영상 : 각 채널별 8비트, 24비트 개의 색 표현 가능
### (6) 이진 영상
### (7) 영상의 용량 : 시간(s)*프레임(f/s)*화소의 수*화소당 비트

## 2) 컬러 공간에 대한 이해
### (1) 컬러는 인가의 눈에 보이는 가시 광선
### (2) 빛의 3원색 : R, G, B 간의 가산 혼합
### (3) 모니터에서는 RGB를 조합해 사용함
### (4) 영상의 정의

* 컬러를 표현하는 화소값의 배열

### (5) 흑백 영상 분리

* 1. RGB 컬러 공간 : 0.333R+0.333B+0.333G
  - NTSC 제안
  - 각 RGB값 중 하나만 사용
  - Green만 사용
  - Gray level = (R^2+B^2+G^2)^1/2 / 3^1/2
  - Gray level = 0.212671R + 0.715160G + 0.071169B

### (6) 다른 영상 처리 응용에 한계

* RGB 컬러 요소들은 상호 관계가 너무 커서 특정 생성만 분리하기 어려움

### (7) HSI 컬러 공간

* 색상, 채도, 명도로 구분한 컬러 공간으로 인간의 시각 시스템과 유사

## 3) HSI 컬러 공간
### (1) 색의 3 요소

* 색상(hue) : pure colore
* 채도(saturation) : white 와 pure color 와의 혼합 비율
* 명도(Intensity) : 색의 밝고 어두운 정도

### (2) 색입체

* 먼셀, 오스왈드, P.G.C.S 등
* Hue : 원통모양의 주변, 0 ~ 360
* Satuation : 중심으로부터의 거리, 0 ~ 1
* Intensity : 하단 꼭지점에서 최상부 까지의 거리, 0 ~ 1, 색의 표현 범위가 달라짐

### (3) RGB -> HSI

* H = { Θ         if B<=G
* ㅤㅤ{ 360 - 0    if B<=G
* Θ = cos^-1[1/2*[(R-G)+(R+B)]/((R-G)^2+(R-B)(G-B))^1/2]
* S = 1 - 3/(R+G+B)`*`[min(R,G,B)]
* I = 1/3*(R+G+B)

### (4) CMYK 컬러 공간 : Printer

* 청록(Cyan) : C=255-R
* 자홍(Magenta) : M=255-G
* 노랑(Yellow) : Y=255-B
* 감산 혼합
* C+M+Y= 검정
* K = min(C,M,Y)
* C = 기존 C - K
* M = 기존 M - K
* Y = 기존 Y - K
* 인쇄를 보낼 때는 CMYK 컬러 공간으로 변환해 보내는 것이 좋다
* CMYK 컬러 공간의 한계
  - RGB보다 범위에 한계
  - 다소 뿌옇게 인쇄
  - CMYK 형태로 직접 모니터로 불러들여 작업하지 않음

## 5) 다른 컬러 공간
### (1) YIQ

* 인간의 시각체계와 유사하게 흉내낸 최초의 색상공간
* Y는 명조, I는 orange-cyan, Q는 Green-Magenta
* 1950년대, 컬러 텔레비전(NTSC방식) 개발자들의 의해 구성

### (2) YCbCr

* 색상정보로 부터 명도를 분리하는 또 하나의 다른 색상 공간
* Y는 명도, Cb는 푸른색, Cr, 붉은색
* JPEG, MPEG 및 디지털 TV의 표준으로 사용

### (3) CIE LAB : uniform color space

* L`*`, a`*`, b`*`
* L`*` 는 명도, a`*` red와 green, b`*`는 yellow와 blue

# 3. 화소값 기본 처리
## 1) 영상의 밝기 조절
### (1) 명암도 영상(흑백 영상)

* 한 화소당 8비트의 데이터 크기
* 0 ~ 255의 범위

### (2) 명암값을 더하거나 뺄 경우

* 0이하 이거나 255이상일 때 문제 발생
* 클랭핌을 이용한 해결
  - Saturation : 0이하 -> 0, 255 이상 -> 255
  - Wrap : 256 = 1, 257 = 2, 258 = 3, 반전 시키는 방법이지만 명암 불균등을 낳는다.

### (3) 영상의 산술 연산

* 밝게 = 255에 가깝게
* 어둡게 = 0에 가깝게

### (4) 산술 연산 적용 예

* 차영상 : 움직임 추적에 쓰임

## 2) 영상의 명암대비 조절
### (1) 명암 대비(Contrast) : 명암값의 분포

* 낮음 명암 대비 : 명암차가 적음
* 높은 명암 대비 : 명암차가 큼

### (2) 대비의 증가 = 곱셈 연산
### (3) 대비의 감소 = 나눗셈 연산

## 3) 히스토그램
### (1) 히스토그램

* 각화소의 명암값의 개수
* 영상의 명암 값 프로필(profile) - > 히스토그램 유사도를 사용한 영상 비교에 유용하다

## 4) 히스토그램 평활화

* 한 쪽에 치우친 명암 분포를 가진 히스토그램을 재분배 하는 과정을 거쳐 일정한 분포를 가지게 하는 히스토그램
* h(i) = (H(i)/Nt)*Gmax
* h(i) : 정규화 합 히스토그램
* H(i) : 누적 히스토그램
* Nt : 영상에서 픽셀의 총 개수
* Gmax : 영상의 최대 밝기

## 5) 히스토그램 스트레칭

* 명암 대비 확장, 명암 대비 스트레칭
* 낮은 대비의 히스토그램을 균등한 분포로 만드는 알고리즘
* X: 기존 명암 값
* low : 히스토그램에서 가장 작은 화소값
* high : 히스토그램에서 가장 큰 화소값
* 새로운 명암 값 = 255*(X-low)/(high-low)
* 스트레칭 변형 : 엔드인 탐색(ends-in search)
  - low, high의 범위 값을 지정하여 스트레칭 한다. 히스토그램의 특정 부분에 화소들이 치우진 형상을 보정하는데 유용하다.
* 새로운 명암 값 = {  0                                 for  X<=low
* ㅤㅤㅤㅤㅤㅤㅤㅤ{  255*(x-low)/(high-low)            for  low<=X<high
* ㅤㅤㅤㅤㅤㅤㅤㅤ{  255                               for  high<=X

## 6) 명암 변환
### (1) 명암 변환(Intensity Transformation)

* 미리 지정된 함수 f(x)를 바탕으로 이진 화소값을 새로운 화소값으로 바꿔주는 알고리즘
* 널 변환(Null Transforamtion) : f(x) = x , 원영상과 같음
* 역 변환(Inverse Transformation) : f(x) = 255 - x (음화 영상,negative image)

### (2) 비트 플래너 슬라이싱(bit-planner slicing) 변환

* 각 비트에 대하여 0인지 1인지 검사하여 하나의 영상 형태로 만든 것을 비트 평면이라고 부른다
* msb는 영상의 윤곽 정보를 가장 잘 간직하고 있다.
* lsb는 영상의 윤곽 정보를 거의 저장하고 있지 않다.
* 비트 평면 분할은 특정 비트의 중요도를 분석하는데 중요한 정보를 제공한다. 예) 영상 압축, 워터마킹 기법에 적용

## 7) 이진 영상 변환 및 처리
### (1) 이진화

* 배경과 객체의 간단한 분리, 영상의 간략화 등의 목적으로 영상 분석 분야에서 필수적인 전처리 과정이다

### (2) 경계값 설정 방법에 따른 이진 영상 생성 알고리즘

* 히스토그램의 분포를 파악하여 적합한 경계값을 설정
* 블록 이진화 기법 적용 -> 블록으로 나뉘어 평균값을 임계로
* 이중 경계값 설정
* 적응적 경계값
* 반복적 경계값
* 난수 경계값

### (3) 단일 경계값과 이중 경계값 설정을 이용한 이진 영상 변환

* 단일 경계값을 이용한 이진 영상 변환
* Binary-image[x][y] = { 1                if Gray-image[x][y]>=threshold
* ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ{ 0                else Gray-image[x][y]<threshold
* 이중 경계값을 이용한 이진 영상 변환
* Binary-image[x][y] = { 1         if low-threshold<=Gray-image[x][y]<high-threshold
* ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ{ 0         otherwise

### (4) 히스토그램 분포를 이용한 이진 영상 변환

* Otsu(온츄) Algorithm
* 영상의 히스토그램의 형태가 쌍봉형이라고 가정 했을 때 그 사이의 계곡점을 찾아 임계값으로 하고 분할 후, 분할 된 클래스 사이의 분산을 최대화 시키는 임계값을 찾는 방법
* 클래스 내의 분산과 클래스 간의 분산화 전체 구간에서의 분산을 이용하여 클래스 간의 분산이 최대가 될 때의 값(클래스 내의 분산이 가장 작을 때)을 임계값으로 한다.
* 전체 분산 : αa^2(t) = αw^2(t) + αb^2(t)
* 클래스 내의 분산 : αw^2(t) = W1(t)α1^2(t) + W2(t)α2^2(t)
* 클래스 간의 분산 : αb^2(t) = αb^2-αw^2 = W1(t)W2(t)[u1(t)-u2(t)]^2
* Wn : 전체 클래스에 대한 각 클래스의 확률
* un : 각 클래스에 대한 평균 명도값

### (5) 반본적 경계값 설정 을 이용한 이진 영상 변환

* 영상의 화소 평균 값을 구할 때 모든 화소의 값을 더해서 전체화소의 개수로 나누어 평균을 계산하는 것 보다 수행 속도 면에서 훨씬 빠른 것으로 알려져 있다.
* step 1. 모든 화소값의 평균값을 계산하여 초기 임계값을 T라고 한다
* step 2. 그레이 스케일 값이 T 보다 작은 픽셀들의 그레이 스케일 값의 평균 u1이라고 하고, T보다 큰 스케일 값의 평균을 u2라고 하여 임계 값을 다음과 같이 계산한다
* T = (u1+u2)/2
* step 3. T간의 변화가 없을 때 가지 반복한다.

